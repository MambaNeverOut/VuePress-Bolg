---
title: "构造函数"
sidebarDepth: 2
---

- 相同的代码使用多次，就应该使用函数进行封装
- 相同的属性需要使用多次，就应该做成共用属性（原型或类）
- 相同的原型需要使用多次，就应该使用继承（Event Bus）

```
class view extends EventBus{
  constructor(){
    super()
  }
}
```

## 基于 class 实现继承

```
class Parent{
  constructor(name1){
    this.name = name1
  }
  pMethod(){
    console.log(this.name1)
  }
}

class Child extends Parent{
  constructor(name2,name1){
    super(name1)  // Parent Constructor
    this.name2 = name2
  }
  cMethod(){
    console.log(this.name2)
  }
}
```

- 构造函数中使用的 super()只能在构造函数中使用，并且必须在使用 this 关键字前调用

## 基于原型实现继承

```js
function Parent(name1) {
  this.name1 = name1;
}
Parent.prototype.pMethod = function () {
  console.log(this.name1);
};
function Child(name2, name1) {
  Parent.call(this.name1); // 核心代码
  this.name2 = name2;
}
Child.prototype._proto_ = Parent.prototype; // 核心代码
Child.prototype.cMethod = function () {
  console.log(this.name2);
};
Child.prototype.constructor = Child; // 核心代码
```

- 老写法

```js
const empty = function () {};
empty.prototype = Parent.prototype;
Child.prototype = new empty();
```

- 使用新 api 的写法

```js
Human.prototype = Object.create(Mammal.prototype);
Human.prototype.constructor = Human;
```
